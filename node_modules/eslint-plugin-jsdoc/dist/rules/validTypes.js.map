{"version":3,"sources":["../../src/rules/validTypes.js"],"names":["asExpression","jsdoc","report","utils","tags","forEach","tag","validTypeParsing","type","tagName","err","error","includes","endChar","slice","memberofError","startChar","charAt","name","thisNamepath","description","replace","test","thatNamepath","isNamepathTag","passesEmptyNamepathCheck","isTagWithType","iterateAllJsdocs","meta"],"mappings":"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","sourcesContent":["import {parse} from 'jsdoctypeparser';\nimport iterateJsdoc from '../iterateJsdoc';\n\nconst asExpression = /as\\s+/;\n\nexport default iterateJsdoc(({\n  jsdoc,\n  report,\n  utils\n}) => {\n  if (!jsdoc.tags) {\n    return;\n  }\n  jsdoc.tags.forEach((tag) => {\n    const validTypeParsing = function (type, tagName) {\n      try {\n        parse(type);\n      } catch (err) {\n        let error = err;\n\n        if (tagName) {\n          if (['memberof', 'memberof!'].includes(tagName)) {\n            const endChar = type.slice(-1);\n            if (['#', '.', '~'].includes(endChar)) {\n              try {\n                parse(type.slice(0, -1));\n                error = {};\n              } catch (memberofError) {\n                // Use the original error for including the whole type\n              }\n            }\n          } else if (tagName === 'borrows') {\n            const startChar = type.charAt();\n            if (['#', '.', '~'].includes(startChar)) {\n              try {\n                parse(type.slice(1));\n                error = {};\n              } catch (memberofError) {\n                // Use the original error for including the whole type\n              }\n            }\n          }\n        }\n\n        if (error.name === 'SyntaxError') {\n          report('Syntax error in type: ' + type, null, tag);\n\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    if (tag.tag === 'borrows') {\n      const thisNamepath = tag.description.replace(asExpression, '');\n\n      if (!asExpression.test(tag.description) || !thisNamepath) {\n        report('@borrows must have an \"as\" expression. Found \"' + tag.description + '\"', null, tag);\n\n        return;\n      }\n\n      if (validTypeParsing(thisNamepath, 'borrows')) {\n        const thatNamepath = tag.name;\n\n        validTypeParsing(thatNamepath);\n      }\n    } else if (utils.isNamepathTag(tag.tag)) {\n      if (utils.passesEmptyNamepathCheck(tag)) {\n        return;\n      }\n      validTypeParsing(tag.name, tag.tag);\n    } else if (tag.type && utils.isTagWithType(tag.tag)) {\n      validTypeParsing(tag.type);\n    }\n  });\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    type: 'suggestion'\n  }\n});\n"],"file":"validTypes.js"}