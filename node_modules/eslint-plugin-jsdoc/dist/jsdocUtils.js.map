{"version":3,"sources":["../src/jsdocUtils.js"],"names":["getFunctionParameterNames","functionNode","getParamName","param","_","has","name","left","type","get","argument","parameter","Error","params","map","getJsdocParameterNamesDeep","jsdoc","targetTagName","jsdocParameterNames","filter","tags","tag","getJsdocParameterNames","includes","getPreferredTagName","tagPreference","values","preferredTagName","findKey","tagNames","aliases","isValidTag","additionalTagNames","validTagNames","keys","concat","flatten","additionalTags","customTags","allTags","hasTag","targetTagLower","toLowerCase","some","doc","hasATag","targetTagNames","hasDefinedTypeReturnTag","tagType","trim","namepathDefiningTags","namepathPointingTags","isNamepathDefiningTag","tagName","isNamepathPointingTag","checkSeesForNamepaths","isNamepathTag","potentiallyEmptyNamepathTags","isPotentiallyEmptyNamepathTag","tagsWithTypes","closureTagsWithTypes","tagsWithTypesAliases","isTagWithType","LOOP_STATEMENTS","STATEMENTS_WITH_CHILDREN","RETURNFREE_STATEMENTS","ENTRY_POINTS","lookupTable","ReturnStatement","is","node","check","IfStatement","consequent","alternate","body","SwitchStatement","cases","item","statement","TryStatement","BlockStatement","block","handler","finalizer","context","FunctionExpression","ignoreAsync","async","ArrowFunctionExpression","expression","FunctionDeclaration","hasReturnValue","parseClosureTemplateTag","source","split","enforcedContexts","defaultContexts","options","contexts","getContextObject","checkJsdoc","reduce","obj","prop"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport tagNames from './tagNames';\n\nconst getFunctionParameterNames = (functionNode : Object) : Array<string> => {\n  const getParamName = (param) => {\n    if (_.has(param, 'name')) {\n      return param.name;\n    }\n\n    if (_.has(param, 'left.name')) {\n      return param.left.name;\n    }\n\n    if (param.type === 'ObjectPattern' || _.get(param, 'left.type') === 'ObjectPattern') {\n      return '<ObjectPattern>';\n    }\n\n    if (param.type === 'ArrayPattern' || _.get(param, 'left.type') === 'ArrayPattern') {\n      return '<ArrayPattern>';\n    }\n\n    if (param.type === 'RestElement') {\n      return param.argument.name;\n    }\n\n    if (param.type === 'TSParameterProperty') {\n      return getParamName(param.parameter);\n    }\n\n    throw new Error('Unsupported function signature format.');\n  };\n\n  return functionNode.params.map(getParamName);\n};\n\n/**\n * Gets all parameter names, including those that refer to a path, e.g. \"@param foo; @param foo.bar\".\n */\nconst getJsdocParameterNamesDeep = (jsdoc : Object, targetTagName : string) : Array<string> => {\n  let jsdocParameterNames;\n\n  jsdocParameterNames = _.filter(jsdoc.tags, {\n    tag: targetTagName\n  });\n\n  jsdocParameterNames = _.map(jsdocParameterNames, 'name');\n\n  return jsdocParameterNames;\n};\n\nconst getJsdocParameterNames = (jsdoc : Object, targetTagName : string) : Array<string> => {\n  let jsdocParameterNames;\n\n  jsdocParameterNames = getJsdocParameterNamesDeep(jsdoc, targetTagName);\n\n  jsdocParameterNames = jsdocParameterNames.filter((name) => {\n    return !name.includes('.');\n  });\n\n  return jsdocParameterNames;\n};\n\nconst getPreferredTagName = (name : string, tagPreference : Object = {}) : string => {\n  if (_.values(tagPreference).includes(name)) {\n    return name;\n  }\n\n  if (_.has(tagPreference, name)) {\n    return tagPreference[name];\n  }\n\n  const preferredTagName = _.findKey(tagNames, (aliases) => {\n    return aliases.includes(name);\n  });\n  if (preferredTagName) {\n    return preferredTagName;\n  }\n\n  return name;\n};\n\nconst isValidTag = (name : string, additionalTagNames : Object) : boolean => {\n  const validTagNames = _.keys(tagNames).concat(_.flatten(_.values(tagNames)));\n  const additionalTags = additionalTagNames.customTags || [];\n  const allTags = validTagNames.concat(additionalTags);\n\n  return allTags.includes(name);\n};\n\nconst hasTag = (jsdoc : Object, targetTagName : string) : boolean => {\n  const targetTagLower = targetTagName.toLowerCase();\n\n  return _.some(jsdoc.tags, (doc : Object) => {\n    return doc.tag.toLowerCase() === targetTagLower;\n  });\n};\n\nconst hasATag = (jsdoc : Object, targetTagNames : Array) : boolean => {\n  return targetTagNames.some((targetTagName) => {\n    return hasTag(jsdoc, targetTagName);\n  });\n};\n\n/**\n * Checks if the JSDoc comment declares a return value.\n *\n * @param {JsDocTag} tag\n *   the tag which should be checked.\n * @returns {boolean}\n *   true in case a return value is declared; otherwise false.\n */\nconst hasDefinedTypeReturnTag = (tag) => {\n  // The function should not continue in the event @returns is not defined...\n  if (typeof tag === 'undefined' || tag === null) {\n    return false;\n  }\n\n  // .. same applies if it declares `@returns {undefined}` or `@returns {void}`\n  const tagType = tag.type.trim();\n  if (tagType === 'undefined' || tagType === 'void') {\n    return false;\n  }\n\n  // In any other case, something must be returned, and\n  // a return statement is expected\n  return true;\n};\n\nconst namepathDefiningTags = [\n  // NOT USEFUL WITHOUT NAMEPATH\n  'external', 'host',\n  'name',\n  'typedef',\n\n  // MAY BE USEFUL WITHOUT NAMEPATH\n  'event',\n\n  // MAY BE USEFUL WITHOUT NAMEPATH (OR\n  //  BLOCK CAN USE NAMEPATH FROM ELSEWHERE)\n  'class', 'constructor',\n  'constant', 'const',\n  'callback',\n  'function', 'func', 'method',\n  'interface',\n  'member', 'var',\n  'mixin',\n  'namespace'\n];\n\nconst namepathPointingTags = [\n  // NOT USEFUL WITHOUT NAMEPATH\n  'alias',\n  'augments', 'extends',\n\n  // `borrows` has a different format, however, so needs special parsing\n  'borrows',\n  'lends',\n  'memberof',\n  'memberof!',\n  'mixes',\n  'this',\n\n  // MAY BE USEFUL WITHOUT NAMEPATH\n  'emits',\n  'fires',\n  'listens'\n];\n\nconst isNamepathDefiningTag = (tagName) => {\n  return namepathDefiningTags.includes(tagName);\n};\n\nconst isNamepathPointingTag = (tagName, checkSeesForNamepaths) => {\n  return namepathPointingTags.includes(tagName) ||\n    tagName === 'see' && checkSeesForNamepaths;\n};\n\nconst isNamepathTag = (tagName, checkSeesForNamepaths) => {\n  return isNamepathDefiningTag(tagName) ||\n    isNamepathPointingTag(tagName, checkSeesForNamepaths);\n};\n\nconst potentiallyEmptyNamepathTags = [\n  // These may serve some minor purpose when empty or\n  //  their namepath can be expressed elsewhere on the block\n  'event',\n  'callback',\n  'class', 'constructor',\n  'constant', 'const',\n  'function', 'func', 'method',\n  'interface',\n  'member', 'var',\n  'mixin',\n  'namespace',\n  'listens', 'fires', 'emits'\n];\n\nconst isPotentiallyEmptyNamepathTag = (tag) => {\n  return potentiallyEmptyNamepathTags.includes(tag);\n};\n\nlet tagsWithTypes = [\n  'class',\n  'constant',\n  'enum',\n  'implements',\n  'member',\n  'module',\n  'namespace',\n  'param',\n  'property',\n  'returns',\n  'throws',\n  'type',\n  'typedef',\n  'yields'\n];\n\nconst closureTagsWithTypes = [\n  'package', 'private', 'protected', 'public', 'static'\n];\n\nconst tagsWithTypesAliases = [\n  'constructor',\n  'const',\n  'var',\n  'arg',\n  'argument',\n  'prop',\n  'return',\n  'exception',\n  'yield'\n];\n\ntagsWithTypes = tagsWithTypes.concat(tagsWithTypesAliases, closureTagsWithTypes);\n\nconst isTagWithType = (tagName) => {\n  return tagsWithTypes.includes(tagName);\n};\n\nconst LOOP_STATEMENTS = ['WhileStatement', 'DoWhileStatement', 'ForStatement', 'ForInStatement', 'ForOfStatement'];\n\nconst STATEMENTS_WITH_CHILDREN = [\n  '@loop',\n  'SwitchStatement',\n  'IfStatement',\n  'BlockStatement',\n  'TryStatement'\n];\n\nconst RETURNFREE_STATEMENTS = [\n  'VariableDeclaration',\n  'ThrowStatement',\n  'FunctionDeclaration',\n  'BreakStatement',\n  'ContinueStatement',\n  'LabeledStatement',\n  'DebuggerStatement',\n  'EmptyStatement',\n  'WithStatement',\n  'ThrowStatement',\n  'ExpressionStatement'\n];\n\nconst ENTRY_POINTS = ['FunctionDeclaration', 'ArrowFunctionExpression', 'FunctionExpression'];\n\n/* eslint-disable sort-keys */\nconst lookupTable = {\n  ReturnStatement: {\n    is (node) {\n      return node.type === 'ReturnStatement';\n    },\n    check (node) {\n      /* istanbul ignore next */\n      if (!lookupTable.ReturnStatement.is(node)) {\n        return false;\n      }\n\n      // A return without any arguments just exits the function\n      // and is typically not documented at all in jsdoc.\n      if (node.argument === null) {\n        return false;\n      }\n\n      return true;\n    }\n  },\n  IfStatement: {\n    is (node) {\n      return node.type === 'IfStatement';\n    },\n    check (node) {\n      /* istanbul ignore next */\n      if (!lookupTable.IfStatement.is(node)) {\n        return false;\n      }\n\n      if (lookupTable['@default'].check(node.consequent)) {\n        return true;\n      }\n\n      if (node.alternate && lookupTable['@default'].check(node.alternate)) {\n        return true;\n      }\n\n      return false;\n    }\n  },\n  '@loop': {\n    is (node) {\n      return LOOP_STATEMENTS.includes(node.type);\n    },\n    check (node) {\n      return lookupTable['@default'].check(node.body);\n    }\n  },\n  SwitchStatement: {\n    is (node) {\n      return node.type === 'SwitchStatement';\n    },\n    check (node) {\n      for (const item of node.cases) {\n        for (const statement of item.consequent) {\n          if (lookupTable['@default'].check(statement)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n  },\n  TryStatement: {\n    is (node) {\n      return node.type === 'TryStatement';\n    },\n    check (node) {\n      /* istanbul ignore next */\n      if (!lookupTable.TryStatement.is(node)) {\n        return false;\n      }\n\n      if (lookupTable.BlockStatement.check(node.block)) {\n        return true;\n      }\n\n      if (node.handler && node.handler.body) {\n        if (lookupTable['@default'].check(node.handler.body)) {\n          return true;\n        }\n      }\n      if (lookupTable.BlockStatement.check(node.finalizer)) {\n        return true;\n      }\n\n      return false;\n    }\n  },\n  BlockStatement: {\n    is (node) {\n      return node.type === 'BlockStatement';\n    },\n    check (node, context) {\n      // E.g. the catch block statement is optional.\n      /* istanbul ignore next */\n      if (typeof node === 'undefined' || node === null) {\n        return false;\n      }\n\n      /* istanbul ignore next */\n      if (!lookupTable.BlockStatement.is(node)) {\n        return false;\n      }\n\n      for (const item of node.body) {\n        if (lookupTable['@default'].check(item, context)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  },\n  FunctionExpression: {\n    is (node) {\n      return node.type === 'FunctionExpression';\n    },\n    check (node, context, ignoreAsync) {\n      return !ignoreAsync && node.async || lookupTable.BlockStatement.check(node.body, context);\n    }\n  },\n  ArrowFunctionExpression: {\n    is (node) {\n      return node.type === 'ArrowFunctionExpression';\n    },\n    check (node, context, ignoreAsync) {\n      // An expression always has a return value.\n      return node.expression ||\n        !ignoreAsync && node.async ||\n        lookupTable.BlockStatement.check(node.body, context);\n    }\n  },\n  FunctionDeclaration: {\n    is (node) {\n      return node.type === 'FunctionDeclaration';\n    },\n    check (node, context, ignoreAsync) {\n      return !ignoreAsync && node.async || lookupTable.BlockStatement.check(node.body, context);\n    }\n  },\n  '@default': {\n    check (node, context) {\n      // In case it is a `ReturnStatement`, we found what we were looking for\n      if (lookupTable.ReturnStatement.is(node)) {\n        return lookupTable.ReturnStatement.check(node, context);\n      }\n\n      // In case the element has children, we need to traverse them.\n      // Examples are BlockStatement, Choices, TryStatement, Loops, ...\n      for (const item of STATEMENTS_WITH_CHILDREN) {\n        if (lookupTable[item].is(node)) {\n          return lookupTable[item].check(node, context);\n        }\n      }\n\n      // Everything else cannot return anything.\n      /* istanbul ignore next */\n      if (RETURNFREE_STATEMENTS.includes(node.type)) {\n        return false;\n      }\n\n      /* istanbul ignore next */\n      // If we end up here, we stumbled upon an unknown element.\n      // Most likely it is enough to add it to the blacklist.\n      //\n      // throw new Error('Unknown node type: ' + node.type);\n      return false;\n    }\n  }\n};\n\n/**\n * Checks if the source code returns a return value.\n * It traverses the parsed source code and returns as\n * soon as it stumbles upon the first return statement.\n *\n * @param {Object} node\n *   the node which should be checked.\n * @param {Object} context\n * @param {boolean} ignoreAsync\n *   ignore implicit async return.\n * @returns {boolean}\n *   true in case the code returns a return value\n */\nconst hasReturnValue = (node, context, ignoreAsync) => {\n  // Loop through all of our entry points\n  for (const item of ENTRY_POINTS) {\n    if (lookupTable[item].is(node)) {\n      return lookupTable[item].check(node, context, ignoreAsync);\n    }\n  }\n  /* istanbul ignore next */\n  throw new Error('Unknown element ' + node.type);\n};\n\n/** @param {string} tag */\n/*\nconst isInlineTag = (tag) => {\n  return /^(@link|@linkcode|@linkplain|@tutorial) /.test(tag);\n};\n*/\n\n/**\n * Parses GCC Generic/Template types\n *\n * @see {https://github.com/google/closure-compiler/wiki/Generic-Types}\n * @param {JsDocTag} tag\n * @returns {Array<string>}\n */\nconst parseClosureTemplateTag = (tag) => {\n  return tag.source\n    .split('@template')[1]\n    .split(',')\n    .map((type) => {\n      return type.trim();\n    });\n};\n\n/**\n * Checks user option for `contexts` array, defaulting to\n *   contexts designated by the rule. Returns an array of\n *   ESTree AST types, indicating allowable contexts.\n *\n * @param {*} context\n * @param {true|string[]} defaultContexts\n * @returns {string[]}\n */\nconst enforcedContexts = (context, defaultContexts) => {\n  const {\n    /* istanbul ignore next */\n    contexts = defaultContexts === true ? [\n      'ArrowFunctionExpression',\n      'FunctionDeclaration',\n      'FunctionExpression'\n    ] : defaultContexts\n  } = context.options[0] || {};\n\n  return contexts;\n};\n\nconst getContextObject = (contexts, checkJsdoc) => {\n  return contexts.reduce((obj, prop) => {\n    obj[prop] = checkJsdoc;\n\n    return obj;\n  }, {});\n};\n\nexport default {\n  enforcedContexts,\n  getContextObject,\n  getFunctionParameterNames,\n  getJsdocParameterNames,\n  getJsdocParameterNamesDeep,\n  getPreferredTagName,\n  hasATag,\n  hasDefinedTypeReturnTag,\n  hasReturnValue,\n  hasTag,\n  isNamepathDefiningTag,\n  isNamepathTag,\n  isPotentiallyEmptyNamepathTag,\n  isTagWithType,\n  isValidTag,\n  parseClosureTemplateTag\n};\n"],"file":"jsdocUtils.js"}