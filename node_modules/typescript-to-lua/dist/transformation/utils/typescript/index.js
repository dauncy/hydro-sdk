"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
__export(require("./nodes"));
__export(require("./types"));
// TODO: Move to separate files?
function hasExportEquals(sourceFile) {
    return sourceFile.statements.some(node => ts.isExportAssignment(node) && node.isExportEquals);
}
exports.hasExportEquals = hasExportEquals;
/**
 * Search up until finding a node satisfying the callback
 */
function findFirstNodeAbove(node, callback) {
    let current = node;
    while (current.parent) {
        if (callback(current.parent)) {
            return current.parent;
        }
        else {
            current = current.parent;
        }
    }
}
exports.findFirstNodeAbove = findFirstNodeAbove;
function getFirstDeclarationInFile(symbol, sourceFile) {
    var _a, _b;
    const originalSourceFile = (_a = ts.getParseTreeNode(sourceFile)) !== null && _a !== void 0 ? _a : sourceFile;
    const declarations = ((_b = symbol.getDeclarations()) !== null && _b !== void 0 ? _b : []).filter(d => d.getSourceFile() === originalSourceFile);
    return declarations.length > 0 ? declarations.reduce((p, c) => (p.pos < c.pos ? p : c)) : undefined;
}
exports.getFirstDeclarationInFile = getFirstDeclarationInFile;
function isStandardLibraryDeclaration(context, declaration) {
    const sourceFile = declaration.getSourceFile();
    if (!sourceFile) {
        return false;
    }
    return context.program.isSourceFileDefaultLibrary(sourceFile);
}
function isStandardLibraryType(context, type, name) {
    const symbol = type.getSymbol();
    if (!symbol || (name ? symbol.name !== name : symbol.name === "__type")) {
        return false;
    }
    // Assume to be lib function if no valueDeclaration exists
    const declaration = symbol.valueDeclaration;
    if (!declaration) {
        return true;
    }
    return isStandardLibraryDeclaration(context, declaration);
}
exports.isStandardLibraryType = isStandardLibraryType;
function hasStandardLibrarySignature(context, callExpression) {
    const signature = context.checker.getResolvedSignature(callExpression);
    return signature && signature.declaration ? isStandardLibraryDeclaration(context, signature.declaration) : false;
}
exports.hasStandardLibrarySignature = hasStandardLibrarySignature;
function inferAssignedType(context, expression) {
    var _a;
    return (_a = context.checker.getContextualType(expression)) !== null && _a !== void 0 ? _a : context.checker.getTypeAtLocation(expression);
}
exports.inferAssignedType = inferAssignedType;
function getAllCallSignatures(type) {
    return type.isUnion() ? type.types.flatMap(getAllCallSignatures) : type.getCallSignatures();
}
exports.getAllCallSignatures = getAllCallSignatures;
// Returns true for expressions that may have effects when evaluated
function isExpressionWithEvaluationEffect(node) {
    return !(ts.isLiteralExpression(node) || ts.isIdentifier(node) || node.kind === ts.SyntaxKind.ThisKeyword);
}
exports.isExpressionWithEvaluationEffect = isExpressionWithEvaluationEffect;
//# sourceMappingURL=index.js.map