"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
function isTypeWithFlags(context, type, flags) {
    if (type.symbol) {
        const baseConstraint = context.checker.getBaseConstraintOfType(type);
        if (baseConstraint && baseConstraint !== type) {
            return isTypeWithFlags(context, baseConstraint, flags);
        }
    }
    if (type.isUnion()) {
        return type.types.every(t => isTypeWithFlags(context, t, flags));
    }
    if (type.isIntersection()) {
        return type.types.some(t => isTypeWithFlags(context, t, flags));
    }
    return (type.flags & flags) !== 0;
}
exports.isTypeWithFlags = isTypeWithFlags;
function isStringType(context, type) {
    return isTypeWithFlags(context, type, ts.TypeFlags.String | ts.TypeFlags.StringLike | ts.TypeFlags.StringLiteral);
}
exports.isStringType = isStringType;
function isNumberType(context, type) {
    return isTypeWithFlags(context, type, ts.TypeFlags.Number | ts.TypeFlags.NumberLike | ts.TypeFlags.NumberLiteral);
}
exports.isNumberType = isNumberType;
function isExplicitArrayType(context, type) {
    if (type.symbol) {
        const baseConstraint = context.checker.getBaseConstraintOfType(type);
        if (baseConstraint && baseConstraint !== type) {
            return isExplicitArrayType(context, baseConstraint);
        }
    }
    if (type.isUnionOrIntersection()) {
        return type.types.some(t => isExplicitArrayType(context, t));
    }
    const flags = ts.NodeBuilderFlags.InTypeAlias | ts.NodeBuilderFlags.AllowEmptyTuple;
    let typeNode = context.checker.typeToTypeNode(type, undefined, flags);
    if (typeNode && ts.isTypeOperatorNode(typeNode) && typeNode.operator === ts.SyntaxKind.ReadonlyKeyword) {
        typeNode = typeNode.type;
    }
    return typeNode !== undefined && (ts.isArrayTypeNode(typeNode) || ts.isTupleTypeNode(typeNode));
}
/**
 * Iterate over a type and its bases until the callback returns true.
 */
function forTypeOrAnySupertype(context, type, predicate) {
    var _a;
    if (predicate(type)) {
        return true;
    }
    if (!type.isClassOrInterface() && type.symbol) {
        type = context.checker.getDeclaredTypeOfSymbol(type.symbol);
    }
    return ((_a = type.getBaseTypes()) !== null && _a !== void 0 ? _a : []).some(superType => forTypeOrAnySupertype(context, superType, predicate));
}
function isArrayType(context, type) {
    return forTypeOrAnySupertype(context, type, t => isExplicitArrayType(context, t));
}
exports.isArrayType = isArrayType;
function isFunctionType(context, type) {
    const typeNode = context.checker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.InTypeAlias);
    return typeNode !== undefined && ts.isFunctionTypeNode(typeNode);
}
exports.isFunctionType = isFunctionType;
//# sourceMappingURL=types.js.map