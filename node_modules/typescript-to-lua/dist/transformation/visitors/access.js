"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const lua = require("../../LuaAST");
const builtins_1 = require("../builtins");
const annotations_1 = require("../utils/annotations");
const lua_ast_1 = require("../utils/lua-ast");
const typescript_1 = require("../utils/typescript");
const enum_1 = require("./enum");
const lua_table_1 = require("./lua-table");
function transformElementAccessArgument(context, node) {
    const index = context.transformExpression(node.argumentExpression);
    const type = context.checker.getTypeAtLocation(node.expression);
    const argumentType = context.checker.getTypeAtLocation(node.argumentExpression);
    if (typescript_1.isNumberType(context, argumentType) && typescript_1.isArrayType(context, type)) {
        return lua_ast_1.createExpressionPlusOne(index);
    }
    return index;
}
exports.transformElementAccessArgument = transformElementAccessArgument;
exports.transformElementAccessExpression = (expression, context) => {
    lua_table_1.validateLuaTableElementAccessExpression(context, expression);
    const constEnumValue = enum_1.tryGetConstEnumValue(context, expression);
    if (constEnumValue) {
        return constEnumValue;
    }
    const table = context.transformExpression(expression.expression);
    const argumentType = context.checker.getTypeAtLocation(expression.argumentExpression);
    const type = context.checker.getTypeAtLocation(expression.expression);
    if (typescript_1.isNumberType(context, argumentType) && typescript_1.isStringType(context, type)) {
        const index = context.transformExpression(expression.argumentExpression);
        return lua.createCallExpression(lua.createTableIndexExpression(lua.createIdentifier("string"), lua.createStringLiteral("sub")), [table, lua_ast_1.createExpressionPlusOne(index), lua_ast_1.createExpressionPlusOne(index)], expression);
    }
    return lua.createTableIndexExpression(table, transformElementAccessArgument(context, expression), expression);
};
exports.transformPropertyAccessExpression = (expression, context) => {
    const constEnumValue = enum_1.tryGetConstEnumValue(context, expression);
    if (constEnumValue) {
        return constEnumValue;
    }
    const luaTableResult = lua_table_1.transformLuaTablePropertyAccessExpression(context, expression);
    if (luaTableResult) {
        return luaTableResult;
    }
    const builtinResult = builtins_1.transformBuiltinPropertyAccessExpression(context, expression);
    if (builtinResult) {
        return builtinResult;
    }
    const property = expression.name.text;
    const type = context.checker.getTypeAtLocation(expression.expression);
    const annotations = annotations_1.getTypeAnnotations(type);
    // Do not output path for member only enums
    if (annotations.has(annotations_1.AnnotationKind.CompileMembersOnly)) {
        if (ts.isPropertyAccessExpression(expression.expression)) {
            // in case of ...x.enum.y transform to ...x.y
            return lua.createTableIndexExpression(context.transformExpression(expression.expression.expression), lua.createStringLiteral(property), expression);
        }
        else {
            return lua.createIdentifier(property, expression);
        }
    }
    const callPath = context.transformExpression(expression.expression);
    return lua.createTableIndexExpression(callPath, lua.createStringLiteral(property), expression);
};
exports.transformQualifiedName = (node, context) => {
    const right = lua.createStringLiteral(node.right.text, node.right);
    const left = context.transformExpression(node.left);
    return lua.createTableIndexExpression(left, right, node);
};
//# sourceMappingURL=access.js.map