"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lua = require("../../../../LuaAST");
const function_context_1 = require("../../../utils/function-context");
const lua_ast_1 = require("../../../utils/lua-ast");
const function_1 = require("../../function");
const literal_1 = require("../../literal");
const utils_1 = require("../utils");
function transformMethodDeclaration(context, node, className, noPrototype) {
    // Don't transform methods without body (overload declarations)
    if (!node.body) {
        return undefined;
    }
    let methodName = literal_1.transformPropertyName(context, node.name);
    if (lua.isStringLiteral(methodName) && methodName.value === "toString") {
        methodName = lua.createStringLiteral("__tostring", node.name);
    }
    const type = context.checker.getTypeAtLocation(node);
    const functionContext = function_context_1.getFunctionContextType(context, type) !== function_context_1.ContextType.Void ? lua_ast_1.createSelfIdentifier() : undefined;
    const [paramNames, dots, restParamName] = function_1.transformParameters(context, node.parameters, functionContext);
    const [body] = function_1.transformFunctionBody(context, node.parameters, node.body, restParamName);
    const functionExpression = lua.createFunctionExpression(lua.createBlock(body), paramNames, dots, lua.FunctionExpressionFlags.Declaration, node.body);
    const methodTable = utils_1.isStaticNode(node) || noPrototype
        ? lua.cloneIdentifier(className)
        : lua.createTableIndexExpression(lua.cloneIdentifier(className), lua.createStringLiteral("prototype"));
    return lua.createAssignmentStatement(lua.createTableIndexExpression(methodTable, methodName), functionExpression, node);
}
exports.transformMethodDeclaration = transformMethodDeclaration;
//# sourceMappingURL=method.js.map